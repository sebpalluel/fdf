./.git/COMMIT_EDITMSG:83: 	MAP->tmp_map[M_HEIGHT] = NULL;
./.git/COMMIT_EDITMSG:84:+	VFlipArray(MAP->tmp_map, M_WIDTH, M_HEIGHT);
./.git/COMMIT_EDITMSG:85:+	HFlipArray(MAP->tmp_map, M_WIDTH, M_HEIGHT);
./.git/COMMIT_EDITMSG:86: 	ft_print_array_int(MAP->tmp_map, M_WIDTH, M_HEIGHT);
./.git/logs/HEAD:22:cbd51fa944dec271c1c36ecb63cba5cf7e59a364 726b230194e2d5edca58b62b25378a66bd22f7b6 sebpalluel <sebpalluel@free.fr> 1487687292 +0100	commit: add macro for MAP->heigth, MAP->width and MAP->depth
./.git/logs/refs/heads/master:22:cbd51fa944dec271c1c36ecb63cba5cf7e59a364 726b230194e2d5edca58b62b25378a66bd22f7b6 sebpalluel <sebpalluel@free.fr> 1487687292 +0100	commit: add macro for MAP->heigth, MAP->width and MAP->depth
./mid[0]:1:./.git/COMMIT_EDITMSG:83: 	MAP->tmp_map[M_HEIGHT] = NULL;
./mid[0]:2:./.git/COMMIT_EDITMSG:84:+	VFlipArray(MAP->tmp_map, M_WIDTH, M_HEIGHT);
./mid[0]:3:./.git/COMMIT_EDITMSG:85:+	HFlipArray(MAP->tmp_map, M_WIDTH, M_HEIGHT);
./mid[0]:4:./.git/COMMIT_EDITMSG:86: 	ft_print_array_int(MAP->tmp_map, M_WIDTH, M_HEIGHT);
./mid[0]:5:./.git/logs/HEAD:22:cbd51fa944dec271c1c36ecb63cba5cf7e59a364 726b230194e2d5edca58b62b25378a66bd22f7b6 sebpalluel <sebpalluel@free.fr> 1487687292 +0100	commit: add macro for MAP->heigth, MAP->width and MAP->depth
./mid[0]:6:./.git/logs/refs/heads/master:22:cbd51fa944dec271c1c36ecb63cba5cf7e59a364 726b230194e2d5edca58b62b25378a66bd22f7b6 sebpalluel <sebpalluel@free.fr> 1487687292 +0100	commit: add macro for MAP->heigth, MAP->width and MAP->depth
./mid[0]:7:./src/color.c:100:	else if (z == MAP->depth)
./mid[0]:8:./src/color.c:102:	coef = (double)z / (double)(MAP->depth);
./mid[0]:9:./src/draw.c:63:	ft_give_color(setup, CLR, MAP->pix->z);
./mid[0]:10:./src/draw.c:64:	MAP->pix->x = a->x + round(xyzi[3] * xyzi[0]);
./mid[0]:11:./src/draw.c:65:	MAP->pix->y = a->y + round(xyzi[3] * xyzi[1]);
./mid[0]:12:./src/draw.c:66:	MAP->pix->z = a->z + round(xyzi[3] * xyzi[2]);
./mid[0]:13:./src/draw.c:67:	ft_put_pix(setup, MAP->pix, CLR);
./mid[0]:14:./src/draw.c:76:	ft_pixcpy(a, MAP->pix);
./mid[0]:15:./src/draw.c:98:		ft_draw_line(setup, &MAP->map[i][j], &MAP->map[i + 1][j]);
./mid[0]:16:./src/draw.c:110:		ft_draw_line(setup, &MAP->map[i][j], &MAP->map[i][j + 1]);
./mid[0]:17:./src/draw.c:126:			ft_give_color(setup, CLR, MAP->map[i][j].z);
./mid[0]:18:./src/draw.c:127:			ft_put_pix(setup, &MAP->map[i][j], CLR);
./mid[0]:19:./src/draw_image.c:35:	IMG->image_addr = mlx_get_data_addr(IMG->image, &(IMG->bbp), &(MAP->width)\
./mid[0]:20:./src/read_map.c:136:	MAP->tmp_map[line][col] = ft_atoi(str[0]);
./mid[0]:21:./src/read_map.c:137:	if (MAP->tmp_map[line][col] > max)
./mid[0]:22:./src/read_map.c:139:		ft_hexa_to_color(MAP->lerp_in, (int)ft_strtol(hex, 16));
./mid[0]:23:./src/read_map.c:140:		max = MAP->tmp_map[line][col];
./mid[0]:24:./src/read_map.c:141:		printf("lerp_in %uc %uc %uc\n", MAP->lerp_in->r, MAP->lerp_in->g, MAP->lerp_in->b);
./mid[0]:25:./src/read_map.c:143:	if (MAP->tmp_map[line][col] < min)
./mid[0]:26:./src/read_map.c:145:		ft_hexa_to_color(MAP->lerp_out, (int)ft_strtol(hex, 16));
./mid[0]:27:./src/read_map.c:146:		min = MAP->tmp_map[line][col];
./mid[0]:28:./src/read_map.c:147:		printf("lerp_out %uc %uc %uc\n", MAP->lerp_out->r, MAP->lerp_out->g, MAP->lerp_out->b);
./mid[0]:29:./src/read_map.c:151:		MAP->lerp_in->r = 255;
./mid[0]:30:./src/read_map.c:152:		MAP->lerp_in->g = 255;
./mid[0]:31:./src/read_map.c:153:		MAP->lerp_in->b = 255;
./mid[0]:32:./src/read_map.c:163:		if (!MAP->hexa)
./mid[0]:33:./src/read_map.c:167:			MAP->tmp_map[line][col] = ft_atoi(str);
./mid[0]:34:./src/read_map.c:189:	MAP->hexa = 0;
./mid[0]:35:./src/read_map.c:193:					&& str[i] != ',') || (MAP->hexa && str[i] == ','))
./mid[0]:36:./src/read_map.c:196:			MAP->hexa = 1;
./mid[0]:37:./src/read_map.c:208:	if(!(MAP->tmp_map[line] = (int *)malloc(sizeof(int) * M_WIDTH + 1)))
./mid[0]:38:./src/read_map.c:210:	MAP->tmp_map[line][M_WIDTH] = 0;
./mid[0]:39:./src/read_map.c:296:	MAP->tmp_map[M_HEIGHT] = NULL;
./mid[0]:40:./src/read_map.c:297:	HFlipArray(MAP->tmp_map, M_WIDTH, M_HEIGHT);
./mid[0]:41:./src/read_map.c:298:	VFlipArray(MAP->tmp_map, M_WIDTH, M_HEIGHT);
./mid[0]:42:./src/read_map.c:299:	ft_print_array_int(MAP->tmp_map, M_WIDTH, M_HEIGHT);
./mid[0]:43:./src/read_map.c:314:	MAP->tmp_map = (int**)malloc(sizeof(int*) * M_HEIGHT + 1);
./mid[0]:44:./src/read_map.c:315:	if ((!tab || !tab[0] || !tab[0][0]) || ret_gnl == -1  || !MAP->tmp_map || \
./mid[0]:45:./src/setup.c:116:		if (MAP->tmp_map && MAP->tmp_map[M_HEIGHT - 1])
./mid[0]:46:./src/setup.c:117:			ft_freetab((void **)MAP->tmp_map);
./mid[0]:47:./src/setup.c:118:		if	(MAP->pix)
./mid[0]:48:./src/setup.c:119:			free (MAP->pix);
./mid[0]:49:./src/setup.c:120:		if	(MAP->map)
./mid[0]:50:./src/setup.c:121:			ft_freetab((void **)MAP->map);
./mid[0]:51:./src/setup.c:128:		if (MAP->mid)
./mid[0]:52:./src/setup.c:129:			free(MAP->mid);
./mid[0]:53:./src/update_map.c:19:	if (!(MAP->map = (t_pix**)malloc(sizeof(t_pix*) * M_HEIGHT + 1)))
./mid[0]:54:./src/update_map.c:21:	MAP->mid[0] = (M_WIDTH * M_HEIGHT) / M_WIDTH;
./mid[0]:55:./src/update_map.c:22:	MAP->mid[1] = M_HEIGHT / 2;
./mid[0]:56:./src/update_map.c:24:	while (MAP->tmp_map[++array])
./mid[0]:57:./src/update_map.c:25:		if(!(MAP->map[array] = (t_pix*)malloc(sizeof(t_pix) * M_WIDTH))) // erase + 1, see if V
./mid[0]:58:./src/update_map.c:28:	MAP->map[M_HEIGHT] = NULL;
./mid[0]:59:./src/update_map.c:51:	printf("mid %d %d\n", MAP->mid[0], MAP->mid[1]);
./mid[0]:60:./src/update_map.c:52:	ft_populate_vec3(vec3, (double)((xy[0] - MAP->mid[1]) * STEP), (double)\
./mid[0]:61:./src/update_map.c:53:			((xy[1] - MAP->mid[0]) * STEP),\
./mid[0]:62:./src/update_map.c:54:			(double)(MAP->tmp_map[xy[0]][xy[1]]));
./mid[0]:63:./src/update_map.c:57:	if (vec3->z > MAP->depth)
./mid[0]:64:./src/update_map.c:58:		MAP->depth = vec3->z;
./mid[0]:65:./src/update_map.c:61:	ft_populate_pix(&MAP->map[xy[0]][xy[1]], (int)((CAM->fov / vec3->z) * \
./mid[0]:66:./src/update_map.c:108:	MAP->depth = 0;
./mid[0]:67:./src/update_map.c:121:	ft_print_array_pix(MAP->map, M_WIDTH, M_HEIGHT);
./src/color.c:100:	else if (z == MAP->depth)
./src/color.c:102:	coef = (double)z / (double)(MAP->depth);
./src/draw.c:63:	ft_give_color(setup, CLR, MAP->pix->z);
./src/draw.c:64:	MAP->pix->x = a->x + round(xyzi[3] * xyzi[0]);
./src/draw.c:65:	MAP->pix->y = a->y + round(xyzi[3] * xyzi[1]);
./src/draw.c:66:	MAP->pix->z = a->z + round(xyzi[3] * xyzi[2]);
./src/draw.c:67:	ft_put_pix(setup, MAP->pix, CLR);
./src/draw.c:76:	ft_pixcpy(a, MAP->pix);
./src/draw.c:98:		ft_draw_line(setup, &MAP->map[i][j], &MAP->map[i + 1][j]);
./src/draw.c:110:		ft_draw_line(setup, &MAP->map[i][j], &MAP->map[i][j + 1]);
./src/draw.c:126:			ft_give_color(setup, CLR, MAP->map[i][j].z);
./src/draw.c:127:			ft_put_pix(setup, &MAP->map[i][j], CLR);
./src/draw_image.c:35:	IMG->image_addr = mlx_get_data_addr(IMG->image, &(IMG->bbp), &(MAP->width)\
./src/read_map.c:136:	MAP->tmp_map[line][col] = ft_atoi(str[0]);
./src/read_map.c:137:	if (MAP->tmp_map[line][col] > max)
./src/read_map.c:139:		ft_hexa_to_color(MAP->lerp_in, (int)ft_strtol(hex, 16));
./src/read_map.c:140:		max = MAP->tmp_map[line][col];
./src/read_map.c:141:		printf("lerp_in %uc %uc %uc\n", MAP->lerp_in->r, MAP->lerp_in->g, MAP->lerp_in->b);
./src/read_map.c:143:	if (MAP->tmp_map[line][col] < min)
./src/read_map.c:145:		ft_hexa_to_color(MAP->lerp_out, (int)ft_strtol(hex, 16));
./src/read_map.c:146:		min = MAP->tmp_map[line][col];
./src/read_map.c:147:		printf("lerp_out %uc %uc %uc\n", MAP->lerp_out->r, MAP->lerp_out->g, MAP->lerp_out->b);
./src/read_map.c:151:		MAP->lerp_in->r = 255;
./src/read_map.c:152:		MAP->lerp_in->g = 255;
./src/read_map.c:153:		MAP->lerp_in->b = 255;
./src/read_map.c:163:		if (!MAP->hexa)
./src/read_map.c:167:			MAP->tmp_map[line][col] = ft_atoi(str);
./src/read_map.c:189:	MAP->hexa = 0;
./src/read_map.c:193:					&& str[i] != ',') || (MAP->hexa && str[i] == ','))
./src/read_map.c:196:			MAP->hexa = 1;
./src/read_map.c:208:	if(!(MAP->tmp_map[line] = (int *)malloc(sizeof(int) * M_WIDTH + 1)))
./src/read_map.c:210:	MAP->tmp_map[line][M_WIDTH] = 0;
./src/read_map.c:296:	MAP->tmp_map[M_HEIGHT] = NULL;
./src/read_map.c:297:	HFlipArray(MAP->tmp_map, M_WIDTH, M_HEIGHT);
./src/read_map.c:298:	VFlipArray(MAP->tmp_map, M_WIDTH, M_HEIGHT);
./src/read_map.c:299:	ft_print_array_int(MAP->tmp_map, M_WIDTH, M_HEIGHT);
./src/read_map.c:314:	MAP->tmp_map = (int**)malloc(sizeof(int*) * M_HEIGHT + 1);
./src/read_map.c:315:	if ((!tab || !tab[0] || !tab[0][0]) || ret_gnl == -1  || !MAP->tmp_map || \
./src/setup.c:116:		if (MAP->tmp_map && MAP->tmp_map[M_HEIGHT - 1])
./src/setup.c:117:			ft_freetab((void **)MAP->tmp_map);
./src/setup.c:118:		if	(MAP->pix)
./src/setup.c:119:			free (MAP->pix);
./src/setup.c:120:		if	(MAP->map)
./src/setup.c:121:			ft_freetab((void **)MAP->map);
./src/setup.c:128:		if (MAP->mid)
./src/setup.c:129:			free(MAP->mid);
./src/update_map.c:19:	if (!(MAP->map = (t_pix**)malloc(sizeof(t_pix*) * M_HEIGHT + 1)))
./src/update_map.c:21:	MAP->mid[0] = (M_WIDTH * M_HEIGHT) / M_WIDTH;
./src/update_map.c:22:	MAP->mid[1] = M_HEIGHT / 2;
./src/update_map.c:24:	while (MAP->tmp_map[++array])
./src/update_map.c:25:		if(!(MAP->map[array] = (t_pix*)malloc(sizeof(t_pix) * M_WIDTH))) // erase + 1, see if V
./src/update_map.c:28:	MAP->map[M_HEIGHT] = NULL;
./src/update_map.c:51:	printf("mid %d %d\n", MAP->mid[0], MAP->mid[1]);
./src/update_map.c:52:	ft_populate_vec3(vec3, (double)((xy[0] - MAP->mid[1]) * STEP), (double)\
./src/update_map.c:53:			((xy[1] - MAP->mid[0]) * STEP),\
./src/update_map.c:54:			(double)(MAP->tmp_map[xy[0]][xy[1]]));
./src/update_map.c:57:	if (vec3->z > MAP->depth)
./src/update_map.c:58:		MAP->depth = vec3->z;
./src/update_map.c:61:	ft_populate_pix(&MAP->map[xy[0]][xy[1]], (int)((CAM->fov / vec3->z) * \
./src/update_map.c:108:	MAP->depth = 0;
./src/update_map.c:121:	ft_print_array_pix(MAP->map, M_WIDTH, M_HEIGHT);
